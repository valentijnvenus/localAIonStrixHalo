# Chapter 07: Practical examples

**ğŸ“– Purpose of this chapter**

Learn specific ways to utilize Aider and local LLM in real projects.

**ğŸ¯ Things to consider in this chapter**
```
â–¡ Which development style is yours?
â”œâ”€ Focus on refactoring
â”œâ”€ Mainly bug fixes
â”œâ”€ Focus on code review
â””â”€ Focus on new feature implementation

â–¡ Which of your current projects is taking the most time?
â–¡ Which tasks can be delegated to an LLM?
```

**ğŸ’¡ Structure of this chapter**
1. **Web app refactoring**: Modernize old code
2. **Bug Fix**: Identify and fix errors
3. **Code review**: Receive quality improvement suggestions
4. **New feature implementation**: Build an authentication system from scratch

**ğŸ¤” Check your development style**
```
â–¡ Many improvements to existing code â†’ Focus on 7.1 and 7.3
â–¡ Fighting bugs on a daily basis â†’ Focus on 7.2
â–¡ Focus on new feature development â†’ Focus on 7.4
â–¡ All apply â†’ All sections should be read
```

---

## 7.1 Practical example 1: Web application Restructure

**ğŸ’¡ What you can learn from this example**
- Migrate old framework (Flask) to new framework (FastAPI)
- Addition of asynchronous processing
- Added type hints
- Added validation by Pydantic

**ğŸ¤” Does this apply to you? **
```
â–¡ Legacy code needs improvement
â–¡ I want to rewrite it to modern Python code
â–¡ I want to introduce asynchronous processing
â–¡ I want to improve type safety
```
â†’ Check two or more: **This example will help**

### 7.1.1 Scenario

Refactor your existing Flask application to FastAPI and add asynchronous processing and type hints.

**Original code (Flask)**

```python
# app.py
from flask import Flask, jsonify, request

app = Flask(__name__)

users = {}

@app.route('/users', methods=['GET'])
def get_users():
    return jsonify(list(users.values()))

@app.route('/users', methods=['POST'])
def create_user():
    data = request.json
    user_id = len(users) + 1
    users[user_id] = {'id': user_id, 'name': data['name']}
    return jsonify(users[user_id]), 201

if __name__ == '__main__':
    app.run(debug=True)
```

### 7.1.2 Refactoring with Aider

**ğŸ’¡ Prompt Points**
- Specify specific requirements in a numbered list
- Also clearly states "things that must not be changed" (maintaining the functionality here)
- Explicit technology stack (FastAPI, Pydantic, async/await)

```bash
# move to project directory
cd ~/flask-app

# Start Aider (30B model recommended: for large-scale changes)
aider --model claude-3-5-sonnet-20241022 app.py

# Refactoring instructions (be specific!)
> Convert this Flask application to FastAPI with the following requirements:
> 1. Use FastAPI instead of Flask
> 2. Add async/await for all endpoints
> 3. Add Pydantic models for request/response validation
> 4. Add type hints throughout
> 5. Keep the same functionality (GET and POST /users)
```

**ğŸ”§ Why is this prompt effective? **
- âŒ Bad example: "Change to FastAPI" â†’ Too vague
- âœ… Good example: List 5 specific requirements as above

**Aider generated code (FastAPI)**

```python
# app.py
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
from typing import Dict, List
import asyncio

app = FastAPI(title="User API")

class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)

class UserResponse(BaseModel):
    id: int
    name: str

# In-memory storage
users: Dict[int, Dict[str, any]] = {}
next_id: int = 1

@app.get("/users", response_model=List[UserResponse])
async def get_users() -> List[UserResponse]:
    """Get all users"""
    await asyncio.sleep(0)  # Simulate async operation
    return list(users.values())

@app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate) -> UserResponse:
    """Create a new user"""
    global next_id

    user_dict = {"id": next_id, "name": user.name}
    users[next_id] = user_dict
    next_id += 1

    return user_dict

# Run with: uvicorn app:app --reload
```

**âœ… Points to check results**
```bash
# 1. Syntax check
python -m py_compile app.py
# OK if there are no errors

# 2. Type checking
mypy app.py
# Check if type hints are added correctly

# 3. Execution test
uvicorn app:app --reload
# OK if it can start
```

### 7.1.3 Test generation

**ğŸ’¡ Why is test generation important? **
- Guaranteed operation after refactoring
- Safety net for future changes
- Also functions as a document

```bash
> Generate comprehensive pytest tests for this API
```

**ğŸ”§ Better prompts**
```bash
> Generate comprehensive pytest tests that cover:
> 1. All endpoints (GET /users, POST /users)
> 2. Success cases (200, 201)
> 3. Error cases (422 validation error)
> 4. Edge cases (empty list, invalid data)
> 5. Use pytest fixtures for test client
```

**Tests generated by Aider**

```python
# test_app.py
import pytest
from fastapi.testclient import TestClient
from app import app, users, next_id

@pytest.fixture
def client():
    """Test client fixture"""
    users.clear()
    return TestClient(app)

def test_get_users_empty(client):
    """Test GET /users when no users exist"""
    response = client.get("/users")
    assert response.status_code == 200
    assert response.json() == []

def test_create_user(client):
    """Test POST /users"""
    response = client.post("/users", json={"name": "John Doe"})
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "John Doe"
    assert "id" in data

def test_get_users_after_create(client):
    """Test GET /users after creating users"""
    client.post("/users", json={"name": "Alice"})
    client.post("/users", json={"name": "Bob"})

    response = client.get("/users")
    assert response.status_code == 200
    users_list = response.json()
    assert len(users_list) == 2

def test_create_user_invalid_name(client):
    """Test POST /users with invalid data"""
    response = client.post("/users", json={"name": ""})
    assert response.status_code == 422  # Validation error
```

**Test run**

```bash
> /run pytest test_app.py -v

# output:
# test_app.py::test_get_users_empty PASSED
# test_app.py::test_create_user PASSED
# test_app.py::test_get_users_after_create PASSED
# test_app.py::test_create_user_invalid_name PASSED
# ===== 4 passed in 0.52s =====
```

### 7.1.4 Added documentation

```bash
> Generate a README.md with:
> 1. Project description
> 2. Installation instructions
> 3. API documentation
> 4. Usage examples
```

**Generated README.md** (excerpt)

```markdown
# User API

A simple FastAPI application for managing users.

## Installation

```bash
pip install fastapi uvicorn pytest
```

## Running

```bash
uvicorn app:app --reload
```

## API Endpoints

### GET /users

Get all users.

**Response:**
```json
[
  {"id": 1, "name": "John Doe"},
  {"id": 2, "name": "Jane Smith"}
]
```

### POST /users

Create a new user.

**Request:**
```json
{
  "name": "John Doe"
}
```

**Response:**
```json
{
  "id": 1,
  "name": "John Doe"
}
```

## Testing

```bash
pytest test_app.py -v
```
```

**ğŸ“Š Comparison of development efficiency**
```
Manual refactoring:
- Flask â†’ FastAPI migration: 2 hours
- Added Type hints: 1 hour
- Added Pydantic model: 1 hour
- Test creation: 1.5 hours
Total: 5.5 hours

Aider + local LLM:
- All inclusive: 15 minutes
â†’ **22x faster! **
```

---

## 7.2 Practical example 2: Bug fixing and debugging

**ğŸ’¡ What you can learn from this example**
- Identify and fix errors
- Edge case handling
- Added error handling
- Add Docstrings

**ğŸ¤” Does this apply to you? **
```
â–¡ Suffering from frequent errors such as ZeroDivisionError and IndexError
â–¡ Often forgets to handle edge cases (empty list, None, etc.)
â–¡ Error message is unfriendly
â–¡ Documentation is missing
```
â†’ Check two or more: **This example will help**

### 7.2.1 Buggy code

```python
# buggy_calculator.py
def calculate_average(numbers):
    total = sum(numbers)
    return total / len(numbers)

def find_max(numbers):
    max_num = numbers[0]
    for num in numbers:
        if num > max_num:
            max_num = num
    return max_num

# test
print(calculate_average([1, 2, 3, 4, 5]))  # 3.0
print(calculate_average([]))  # ZeroDivisionError!
print(find_max([]))  # IndexError!
```

### 7.2.2 Fixes in Aider

**ğŸ’¡ Prompt Points**
- Clearly explain the bug (what happens)
- Specify correction policy
- Also specify any improvements you would like added (docstrings, type hints)

```bash
aider buggy_calculator.py

> This code has two bugs:
> 1. calculate_average crashes with ZeroDivisionError when the list is empty
> 2. find_max crashes with IndexError when the list is empty
>
> Fix both bugs by:
> - Adding input validation
> - Raising ValueError with clear messages for invalid input
> - Adding comprehensive docstrings
> - Adding type hints
```

**ğŸ”§ Examples of improved prompts**
```bash
# âŒ Bad example
> fix bugs

# âœ… Good example (above)
> Specific bugs + correction policy + additional improvements
```

**Code modified by Aider**

```python
# buggy_calculator.py
from typing import List

def calculate_average(numbers: List[float]) -> float:
    """
    Calculate the average of a list of numbers.

    Args:
        numbers: A list of numbers

    Returns:
        float: The average of the numbers

    Raises:
        ValueError: If the list is empty

    Examples:
        >>> calculate_average([1, 2, 3, 4, 5])
        3.0
        >>> calculate_average([10, 20])
        15.0
    """
    if not numbers:
        raise ValueError("Cannot calculate average of an empty list")

    total = sum(numbers)
    return total / len(numbers)

def find_max(numbers: List[float]) -> float:
    """
    Find the maximum value in a list of numbers.

    Args:
        numbers: A list of numbers

    Returns:
        float: The maximum value

    Raises:
        ValueError: If the list is empty

    Examples:
        >>> find_max([1, 5, 3, 2])
        5
        >>> find_max([-10, -5, -20])
        -5
    """
    if not numbers:
        raise ValueError("Cannot find max of an empty list")

    max_num = numbers[0]
    for num in numbers[1:]:  # Start from second element
        if num > max_num:
            max_num = num

    return max_num

# Safe usage
try:
    print(calculate_average([1, 2, 3, 4, 5]))  # 3.0
    print(calculate_average([]))  # Raises ValueError
except ValueError as e:
    print(f"Error: {e}")

try:
    print(find_max([10, 20, 15]))  # 20
    print(find_max([]))  # Raises ValueError
except ValueError as e:
    print(f"Error: {e}")
```

### 7.2.3 Adding tests

```bash
> Generate pytest tests that verify the bug fixes
```

```python
# test_buggy_calculator.py
import pytest
from buggy_calculator import calculate_average, find_max

def test_calculate_average_normal():
    assert calculate_average([1, 2, 3, 4, 5]) == 3.0
    assert calculate_average([10, 20]) == 15.0

def test_calculate_average_empty():
    with pytest.raises(ValueError, match="Cannot calculate average"):
        calculate_average([])

def test_find_max_normal():
    assert find_max([1, 5, 3, 2]) == 5
    assert find_max([-10, -5, -20]) == -5

def test_find_max_empty():
    with pytest.raises(ValueError, match="Cannot find max"):
        find_max([])

def test_find_max_single_element():
    assert find_max([42]) == 42
```

**âœ… Confirmation after modification**
```bash
# run the test
pytest test_buggy_calculator.py -v

# Make sure all tests pass
# â†’ Bugs fixed and edge cases handled
```

**ğŸ“Š Efficient bug fixing**
```
Manual fix:
- Bug identification: 10 minutes
- Fixed implementation: 15 minutes
- Test creation: 20 minutes
- Documentation: 10 minutes
Total: 55 minutes

Aider + local LLM:
- All inclusive: 5 minutes
â†’ **11x faster! **
```

---

## 7.3 Practical example 3: Code review and improvement

**ğŸ’¡ What you can learn from this example**
- Performance improvements
- Improved readability
- Added error handling
- Applying best practices

**ğŸ¤” Does this apply to you? **
```
â–¡ Few opportunities to receive code reviews
â–¡ "If it works, it's OK" and it's not possible to improve quality
â–¡ I don't know modern writing methods such as list comprehensions and Pathlib
â–¡ I tend to forget the context manager (with statement)
```
â†’ Check two or more: **This example will help**

### 7.3.1 Code to be reviewed

```python
# data_processor.py
def process_data(data):
    result = []
    for i in range(len(data)):
        if data[i] > 0:
            result.append(data[i] * 2)
    return result

def save_to_file(data, filename):
    f = open(filename, 'w')
    for item in data:
        f.write(str(item) + '\n')
    f.close()
```

### 7.3.2 Reviews on Aider

```bash
aider data_processor.py

> Review this code and suggest improvements for:
> 1. Performance
> 2. Readability
> 3. Error handling
> 4. Best practices
>
> Then apply all improvements.
```

**Aider reviews and improvements**

```python
# data_processor.py
from typing import List, Union
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def process_data(data: List[Union[int, float]]) -> List[Union[int, float]]:
    """
    Process data by doubling all positive numbers.

    Args:
        data: A list of numbers

    Returns:
        A list of doubled positive numbers

    Examples:
        >>> process_data([1, -2, 3, -4, 5])
        [2, 6, 10]
        >>> process_data([])
        []
    """
    # Improvement 1: List comprehension (faster and more readable)
    # Improvement 2: Added type hints
    # Improvement 3: Added docstring
    return [num * 2 for num in data if num > 0]

def save_to_file(
    data: List[Union[int, float, str]],
    filename: Union[str, Path],
    append: bool = False
) -> None:
    """
    Save data to a file, one item per line.

    Args:
        data: A list of items to save
        filename: Path to the output file
        append: If True, append to existing file. If False, overwrite.

    Raises:
        IOError: If file cannot be written
        ValueError: If data is empty

    Examples:
        >>> save_to_file([1, 2, 3], "output.txt")
        >>> save_to_file(["a", "b"], "output.txt", append=True)
    """
    # Improvement 1: Input validation
    if not data:
        raise ValueError("Cannot save empty data")

    # Improvement 2: Path handling
    filepath = Path(filename)

    # Improvement 3: Create parent directories if needed
    filepath.parent.mkdir(parents=True, exist_ok=True)

    # Improvement 4: Context manager (auto-closes file)
    # Improvement 5: Proper mode selection
    mode = 'a' if append else 'w'

    try:
        with filepath.open(mode, encoding='utf-8') as f:
            for item in data:
                f.write(f"{item}\n")

        logger.info(f"Successfully saved {len(data)} items to {filepath}")

    except IOError as e:
        logger.error(f"Failed to save data to {filepath}: {e}")
        raise

# Example usage
if __name__ == "__main__":
    # Process data
    numbers = [1, -2, 3, -4, 5, 0, 6]
    processed = process_data(numbers)
    print(f"Processed: {processed}")  # [2, 6, 10, 12]

    # Save to file
    save_to_file(processed, "output.txt")
```

**Improvement points**
1. âœ… Improve performance with list comprehensions
2. âœ… Improve type safety with type hints
3. âœ… Documented with Docstrings
4. âœ… Resource management with context manager
5. âœ… Added error handling
6. âœ… Added logging
7. âœ… Improved portability by using Pathlib

---

## 7.4 Practical example 4: Implementing new features

**ğŸ’¡ What you can learn from this example**
- Implement functionality from scratch
- Integration of multiple libraries (SQLAlchemy, JWT, bcrypt)
- Security best practices
- REST API design

**ğŸ¤” Does this apply to you? **
```
â–¡ New function implementation required
â–¡ I want to add an authentication system
â–¡ There are security requirements
â–¡ Need to integrate multiple libraries
```
â†’ Check two or more: **This example will help**

### 7.4.1 Requirements

"Please add user authentication function"

**âš ï¸ Problems with ambiguous requirements**
- Implementation details are unclear with just â€œauthenticationâ€
-JWT? session? OAuth?
- What about password hashing?
- What about the database?

**âœ… Convert into clear requirements**
```
1. User model (email + password)
2. Registration endpoint
3. Login endpoint (JWT return)
4. Password hashing (bcrypt)
5. JWT authentication
6. Protected endpoint example
```

### 7.4.2 Implementation in Aider

```bash
aider

> Create a user authentication system with:
> 1. User model with email and hashed password
> 2. Registration endpoint
> 3. Login endpoint that returns JWT token
> 4. Password hashing with bcrypt
> 5. JWT token generation and validation
> 6. Protected endpoint example
>
> Use FastAPI, SQLAlchemy, and python-jose for JWT
```

**Code generated by Aider** (main part)

```python
# auth.py
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel, EmailStr
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional

# Configuration
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Database setup
DATABASE_URL = "sqlite:///./users.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

# Models
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)

Base.metadata.create_all(bind=engine)

# Pydantic schemas
class UserRegister(BaseModel):
    email: EmailStr
    password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

# FastAPI app
app = FastAPI(title="Auth API")

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials"
    )

    try:
        token = credentials.credentials
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception

    return user

@app.post("/register", response_model=Token)
def register(user: UserRegister, db: Session = Depends(get_db)):
    """Register a new user"""
    # Check if user exists
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")

    # Create new user
    hashed_password = get_password_hash(user.password)
    new_user = User(email=user.email, hashed_password=hashed_password)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    # Generate token
    access_token = create_access_token(data={"sub": new_user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/login", response_model=Token)
def login(user: UserLogin, db: Session = Depends(get_db)):
    """Login and get access token"""
    db_user = db.query(User).filter(User.email == user.email).first()

    if not db_user or not verify_password(user.password, db_user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password"
        )

    access_token = create_access_token(data={"sub": db_user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/protected")
def protected_route(current_user: User = Depends(get_current_user)):
    """Protected endpoint example"""
    return {"message": f"Hello, {current_user.email}!"}
```

### 7.4.3 Operation confirmation

```bash
# start server
uvicorn auth:app --reload

# Registration
curl -X POST http://localhost:8000/register \
  -H "Content-Type: application/json" \
  -d '{"email": "[email protected]", "password": "secret123"}'

# output:
# {"access_token": "eyJ...", "token_type": "bearer"}

# Login
curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{"email": "[email protected]", "password": "secret123"}'

# Access the protected endpoint
curl http://localhost:8000/protected \
  -H "Authorization: Bearer eyJ..."

# output:
# {"message": "Hello, [email protected]!"}
```

**âœ… Implementation points**
```bash
# 30B model recommended for complex implementation
aider --model claude-3-5-sonnet-20241022

# Be specific in your prompts
> Create a user authentication system with:
> 1. User model with email and hashed password
> 2. Registration endpoint
> 3. Login endpoint that returns JWT token
> 4. Password hashing with bcrypt
> 5. JWT token generation and validation
> 6. Protected endpoint example
>
> Use FastAPI, SQLAlchemy, and python-jose for JWT
```

**ğŸ”§ Why is this prompt effective? **
- List necessary functions with numbers
- Specify the library to use
- Specify security requirements (bcrypt, JWT)

---

## 7.5 Summary

In this chapter, you learned how to leverage Aider and local LLM in a real project.

**What I put into practice**
âœ… Web application Restructure (Flask â†’ FastAPI)
âœ… Bug fixes and debugging (edge â€‹â€‹case handling)
âœ… Code review and improvement (applying best practices)
âœ… Implementation of new features (authentication system)

**Improved development efficiency**
```
Task Manual Aider Acceleration
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Refactoring 5.5 hours 15 minutes 22x
Bug fix 55 minutes 5 minutes 11x
Code review 45 minutes 8 minutes 5.6x
New feature implementation 3 hours 20 minutes 9x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Average 11.9x
```

**â“ Frequently asked questions**

**Q: The prompt is too long and annoying**
A: Save frequently used prompts in a file and use them by copying and pasting.

**Q: The generated code is different than expected**
A: Modify the prompt by making it more specific or by going back with `/undo`.

**Q: Which model should I use? **
A:
- Easy task (bug fix): 7B model
- Normal task (refactoring): 30B model
- Complex tasks (new feature implementation): 30B model + temperature 0.3

**Q: Can tests be automatically generated? **
A: Yes! It can be generated with `Generate comprehensive pytest tests`.

**Q: Can I use the generated code as is? **
A: 90% possible, but please be sure to check and test.

**ğŸ’¡ Tips for effective usage**
1. **Be specific in your prompts**: List requirements in a numbered list
2. **Use different models**: Easy = 7B, Normal = 30B
3. **Proceed in stages**: Break large changes into smaller pieces.
4. **Always generate tests**: Guaranteed safety
5. **Don't forget to check**: Don't blindly trust the output of LLM

**Next steps**
In the next chapter, you'll learn how to troubleshoot common problems.

**Verification Checklist**
- [ ] You can edit the actual code in Aider
- [ ] Can identify and fix bugs
- [ ] You can request a code review
- [ ] Can implement new features
- [ ] Be able to write prompts specifically

Once you have checked everything, move on to Chapter 08!
